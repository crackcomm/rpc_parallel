#+TITLE: Rpc\_parallel

=Rpc_parallel= is a library that uses processes to achieve
parallelism. Because of the garbage collector and async locks,
thread-level parallelism in OCaml is not achievable.

The library works by spawning processes that start rpc servers. The
spawned process is running /proc/self/exe (i.e. the same executable as
the running process). Communication between a "master" and a "worker"
involves sending rpc queries and receiving rpc responses. The "worker"
already has the code to do computation because it is running the same
binary!

* Mental Model

- =Worker.t= identifies a worker rpc server
- =spawn= (=serve=) starts a worker rpc server in another process (the same
  process)
- =client= connects to a worker rpc server
- =run= dispatches on a connection to a worker rpc server

* Top-level

It is highly recommended for =Rpc_parallel.start_app= and =Rpc_parallel.Make=
calls to be top-level. But the real requirements are:

1) The master's state is initialized before any calls to =spawn=. This will be
   achieved either by =Rpc_parallel.start_app= or
   =Rpc_parallel.Expert.start_master_server_exn=.

2) Spawned workers (runs of your executable with a certain environment variable
   set) must start running as a worker. This will be achieved either by
   =Rpc_parallel.start_app= or =Rpc_parallel.Expert.worker_command=.

3) Spawned workers must be able to find their function implementations when they
   start running as a worker. These implementations are gathered on the
   application of the =Rpc_parallel.Make= functor. So that masters and workers
   agree on certain generated ids, all of the worker implementations must be
   defined in all code paths leading up to =start_app=,
   =start_master_server_exn=, or =worker_command=, and they should be defined in
   the same order.

* Monitoring your workers

Uncaught exceptions in workers will always result in the worker
calling =Shutdown.shutdown=. The master can be notified of these
exceptions in multiple ways:

- If the exception occured in a function implementation =f= before =f= is
  determined, the exception will be returned back to the caller. E.g. the caller
  of =spawn= or =run= will get an =Error.t= describing the exception.

- If the exception occured after =f= is determined, =on_failure exn= will be
  called (in =Monitor.current ()= at the time of =spawn=) in the spawning
  process.

- If =redirect_stderr= specifies a file, the worker will also write its
  exception to that file before shutting down.

* Dealing with long async cycles

Long async cycles can cause the connections to your workers to close.
If you are using =~shutdown_on:Disconnect= (which is recommended!),
then this connection closing will result in your worker shutting down.

You can bump the =max_message_size=, =heartbeat_config=, and
=handshake_timeout= settings that are used for all rpc communication.
These settings are determined by (in descending order of preference):

1) The environment variable =RPC_PARALLEL_RPC_SETTINGS= (see
   =Rpc_settings= in =lib/rpc_parallel/src/parallel.ml= for how to
   construct a value)
2) Arguments supplied to =start_app= or =Expert.start_master_server_exn=
3) The defaults supplied by the =Rpc= library
